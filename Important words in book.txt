DAY 1:


OOP - Object oriented programming

3 main parts

1. ENCASEMENT/ENCAPSULATION
- All C++ programs are composed of the following two fundamental elements:

Program statements (code): This is the part of a program that performs actions and they are called functions.
Program data: The data is the information of the program which affected by the program functions.

Encapsulation is an Object Oriented Programming concept that binds together the data and functions that 
manipulate the data, and that keeps both safe from outside interference and misuse. Data encapsulation 
led to the important OOP concept of data hiding.

Data encapsulation is a mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user.
 
C++ supports the properties of encapsulation and data hiding through the creation of user-defined types, called classes. We already have studied that a class can contain private, protected and public members. 
By default, all items defined in a class are private. For example:

2. INHERITANCE 				
- One of the most important concepts in object-oriented programming is that of inheritance.

Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.

When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.

The idea of inheritance implements the is a relationship. For example, mammal IS-A animal, dog IS-A mammal hence dog IS-A animal as well and so on.

3. POLYMORPHISM				
- The word polymorphism means having many forms. Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.

C++ polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function.


ANSI - "antsy" - American National Standards Institute



DAY 2:

/// Documentation comment

// One-line comment

/* Multi-line comment */

FUNCTIONS - every function has it's own PROTOTYPE usually in header file and it's own DECLARATION usually in cpp file where we declare what this function is going to do



DAY 3:

DATA TYPES
Boolean						 True / False
Character					 256 character values
Integer						 -2 147 483 648 to 2 147 483 647          - unsigned 0 to 4 294 967 295
Short Integer				 	-32 768 to 32767                         	  - unsigned 0 to 65535 
Long Integer				 	-2 147 483 648 to 2 147 483 647           - unsigned 0 to 4 294 967 295
Float						 1.2e-38 to 3.4e38
Double						 2.2e-308 to 1.8e308

KEY WORDS - We shouldn't use these as our variable name

    asm
    auto
    bool			- data type
    break			- used for exiting the loop before the condition is false
    case			- used in switch statement, if variable equals to case value, the following code will be executed
    catch
    char			- data type, 0 == false, any other number == true
    class			- new data type. it has its own methods and members
    const			- define new constant with specific type, number which won't change, can be used also for methods which don't change anything in it
    const_cast
    continue		- used when we need to return at the begining of the loop earlier then at the end of the loop, in that case code after continue won't be executed during that loop run
    default			- used in switch, tells the program what to do if variable doesn't meet any of the case values
    delete			- used to free memory of variable created in junkyard, if we forget to do this we will have memory leaks
    do
    double			- data type
    dynamic_cast
    else			- keyword used for conditions, if (condition) true do something, if it is false do something after the else statement
    enum			- declares new type and every enumerated type has it's own value starting from 0
    explicit
    export
    extern
    false			- 0 value used for boolean data types
    float			- data type
    for			- loop type]
    friend
    goto			- we shouln't be using this loop, it is dangerous in code and there are better loops like while, do while, for 
    if			- used for conditions if something is true or false do something
    inline			- keyword used when we want short function declaration part to be writen everywhere at the code when we call it, it saves time but also increases size 
    int			- data type
    long			- data type
    mutable
    namespace
    new			- used when we want to create variable in junkyard accessible even after our function ends, similar to global variable, but we can control which functions get access to it
    operator
    private			- used for defining which methods or member variables in class are private (not accessable outside of class)
    protected
    public			- used for defining which methods or member variables in class are public
    register
    reinterpret_cast
    return			- return back from void function or method and returns value in other functions
    short			- data type
    signed			- data type with positive and also negative values
    sizeof			- size of an object 
    static
    static_cast
    struct			- structures are a way of storing many different values in variables of potentially different types under the same name
    switch			- used when we want to make different results at different condition/value
    template
    this			- this is a pointer to the actual object we are working with
    throw
    true			- 1 value used for boolean data types
    try
    typedef		- used for making new aliases of some datatype
    typeid
    typename
    union
    unsigned		- data type with only positive values
    using
    virtual
    void			- type of function/method with no return values
    volatile
    wchar_t
    while			- loop type

    and             - &&, when both expressions are true then operator is also true
    and_eq
    bitand
    bitor
    compl
    not             - !, is true if expression is false e.g: if (!(x==5)) it is the same as if (x==5)
    not_eq
    or              - ||, is true if at least one of the expressions is true
    or_eq
    xor             - ^, is true only if at least one of the expression is true but not both at the same time
    xor_eq

SPECIAL CHARACTERS:

char Ring = '\a';
char Backspace = '\b';
char nextFile = '\f';
char newLine = '\n';
char Tab = '\t';
char verticalTab = '\v';
char aostrophe = '\'';
char quotes = '\"';
char questionmark = '\?';
char backslash = '\\';
char octal = '\000';
char hexadecimal = '\x000';


DEFINE and CONST
// Constant Definition - we should use the second one
#define         MY_FIRST_CONSTANT_DEFINITION            = 1;
const int32     MY_SECOND_CONSTANT_DEFINITION           = 1;


// Enum - declares new type and every enumerated type has it's own value starting from 0
//        unless we inicialize any of them, then the next enumerated type will have it's value bigger by 1 than previous one
//        enumerated type in enum is taken as unsigned integer
enum Color
{
    MONDAY,             // 0
    TUESDAY = 100,      // 100
    WEDNESDAY,          // 101
    THURSDAY,           // 102
    FRIDAY = 50,        // 50
    SATURDAY = 98+2,    // 100 - it is possible to make two enumerated type with the same value
    SUNDAY,             // 101
};

RANDOM NUMBER GENERATOR

// Innitialize random seed, we also need to include <ctime> library
srand(time(NULL));

Examples
rand() % 100;         // in the range 0 to 99
rand() % 100 + 1;     // in the range 1 to 100
rand() % 30 + 1985;   // in the range 1985-2014




DAY 4:

COMMANDS: 

All commands in C++ ends with ;

EXPRESSION: 

Everything which gives us some value is expression, expression returns value of: X
All expressions are also commands.

Relational and comparison operators ( ==, !=, >, <, >=, <= )
==	Equal to
!=	Not equal to
<	Less than
>	Greater than
<=	Less than or equal to
>=	Greater than or equal to

Basic Logic Operators

&&   and
||   or
!    not
^    xor

Conditional (ternary) operator - ( ?: )

- Only one operator that expects three expressions
(expression1) ? expression2 : expression3;
If expression1 is true, execute expression2, if false execute expression3

INCERMENT AND DECREMENT:

If we want to add 1 to any variable, we can use ++, for example age++ or ++age
If we want to decrease variable by 1, we can use --, for example --age or age--

 


Day 5:

FUNCTIONS

Every function has its own declaration (which we call prototype) and definiton.
Declaration means we define type, name and parameters.
In definition we write what that function does.

There are three types of declaration.
1) Prototype is in its own file and we include this file using #include
2) Prototype is in file where is also definition
3) Function's definition is just before another function calls it, in this case it is also its own declaration

Every function has it's own return value, if we don't want to return any value we use type void.

Global variable is accessable everywhere, if we have local variable with the same name global variable is suppressed.
We shouldn't be using global variables unless we have to, because it can have catastrophic consequences

We can return values in following examples:
return 5;               // returns number
return (x > 5);         // returns bool state true or false
return (Function());    // returns number returned by Function

Every code followed after word return will not work!

Function main should be used with type int and always end with return 0 to meet ANSI standarts.

FUNCTION OVERLOADING = POLYMORPHISM

In c++ we can use function overloading which means we can use function with the same name but different types or number of arguments
Example:
int MyFunction(int, int);
int MyFunction(long, long);
int MyFunction(long);

Compilator will use correct function based on amount of arguments and their types.

WARNING: Two function with the same name and number of arguments and types but with different return type value will lead to error with compilation!
We have to make sure that we change arguments or their types or name itself if necessary.

INLINE FUCNTIONS

If we use word inline before our function compilator will use body of this function and insert it everywhere in our code, which means program will be
a little bit quicker, because it won't jump from function to function, but on the other hand program will be larger!

RECURSION - two types, direct and indirect
Direct recursion function calls itself.
Indirect recursion calls another function which calls the first function

 
 
 
Day 6: (OOP - Object oriented programming)

CLASSES

For declaration of new class uses key word class

New created object of class is called instance of that class.

Every class has its own public and private members or methods (functions). If not declared by default everything is private. 
Data members should be private.
Declaration of class is also called class interface.

Every method in class (as function) has to have a declaration and definition.
We define methods as following:
First we define its return type, then we use name of the class in which we have our method followed by two :: and name of the method after this we use brackets and inside arguments and their type.
For Example we have class Car and we have method called Start()

Declaration in class: void Start() const
Definition: void Car::Start() const

CONSTRUCTORS AND DESTRUCTORS

They are special methods in class where we can initialize private member variables
They have the same name as a class but in destructor we use symbol ( ~ ) before the name e.g. ~Car(); 
They can have different parameters but they DOONT HAVE a return type.
Constructor and destructor without parametres are called default. Destructors don't have parameters at all.
If we don't make our own default constructor and destructor for class compilator will make it itself. (We will not see it) 
!!! If we declare our own constructor with parameter(s), compiler will not make defaul constructor !!! -> if we will need default constructor we have to write it at this point

CONST in Methods
- we can use key word const at the end of the method if we are telling that this method will not change any vaule of member of that class.

HEADER FILES and SOURCE FILES

- Header file is used for class interface, declaration of class methods and private members
- name.h -> Header file ends with .h or .hpp

- Source file is used for method implementation (how method works and do what they do)
- name.cpp or name.c -> Source file ends with .cpp or .c

STRUCTURES

Structures are a way of storing many different values in variables of potentially different types under the same name.
It is exactly the same thing as class, but in past they had no methods.




Day 7: Program flow

Go To, While, Break, Continue, While(true), Do While, For, Switch, Forever Loop, 




Day 8: Pointers

- variables which point to adress of an object
- & symbol is used for adress, &variable will return adress of this variable
- every pointer has to be initialized or at least set to nullptr

int howOld = 50;
int * pAge = 0;
pAge = &howOld;

it can also be initialized in the same line

int * pAge = &howOld;

(*) - dereference operator - we can use this operator to get the exact value stored at that adress of a pointer

myAge = *pAge; // myAge will be 50 at this point

Key words New and Delete are used for creating and storing data in junkyard
If we delete some object we should set the pointer to 0 (NULL)
It is safe to call delete on null pointer, if we call delete on pointer twice without setting it to nullptr our program will crash

// 1 - Pointer to constant variable, we can't change the variable
const int * pointer1 = nullptr;
// 2 - Constant pointer, we can't change the adress this pointer is pointing to 
int* const pointer2 = nullptr;
// 3 - Both cases above together
const int* const pointer3 = nullptr;




Day 9: References

- reference is alias for a variable

example initialization:
int & r_reference = variable;

there has to be an empty space between type and & but not between & and reference name
reference has to be initialized right away otherwise we will get compiler error
initialize all references!!!

if we are using references we have to be careful, because we are working with the source
and any modification done to that source is permanent, that is the difference between passing
by value and passing by refrence or pointer
to avoid any modification we can use keyword const


Pointers vs References
Most of the time references are better, they are more understandable and easier to use, but we can't change references!!!
If we want to point to one object and then to another, we have to use pointers!
References can't be null and if there is even an slightest chance that the object can be null we have to use pointer

Example:
int *p_int = new int;
if (p_int != NULL)
int &p_int = *p_int;
